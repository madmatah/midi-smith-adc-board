---
alwaysApply: true
---
# Best Practices Guide (Cursor Rules)

## 1. Project Philosophy

**— STM32CubeMX generates only hardware infrastructure**

HAL, CMSIS, startup, FreeRTOS (configuration) only.

**— The project must remain regenerable at any time**

A CubeMX regeneration must never delete or invalidate application code.

**— Code generated by CubeMX implements no business logic**

All application logic is external to generated code.

**— Generated code and user code are strictly separated**

User code lives in directories unknown to CubeMX (`app/`, `bsp/`, `domain/`, `os/`).

**— No CubeMX-generated file is modified outside USER CODE zones**

Any modification outside these zones is forbidden.

---

## Coding Style (Google C++)

**— Google C++ Style Guide is the reference**

Project code follows the Google C++ Style Guide, with a small set of explicit project-level constraints and exceptions documented below.

**— Scope: applies only to project-owned code**

Applies to:
- `app/`, `bsp/`, `os/`, `domain/`, `tests/`

Does not apply to:
- `Core/`, `Drivers/`, `Middlewares/`, `USB_DEVICE/` (STM32CubeMX generated)
- `Third_Party/` (vendored third-party code)

**— File and directory naming**

Our code uses:
- Directories: `lowercase_with_underscores/`
- Files: `lowercase_with_underscores.hpp` and `lowercase_with_underscores.cpp`
- C API boundaries may use `.h` (e.g. headers included by STM32CubeMX-generated `.c` files)

**— C++ symbol naming (summary)**

Use Google conventions:
- Types (classes/structs/enums): `UpperCamelCase` (PascalCase)
- Functions (including class methods): `PascalCase()`
- Accessors and mutators: may be `snake_case()` (e.g. `count()`, `set_count(...)`)
- Variables: `snake_case`
- Class data members: `snake_case_` (trailing underscore)
- Constants: `kUpperCamelCase`
- Namespaces: `lowercase`
- Interfaces: avoid Hungarian notation, use `*Requirements` (e.g. `LoggerRequirements`) and `*_requirements.hpp`

**— Formatting**

Formatting is done with clang-format using `.clang-format`
- Based on Google
- `ColumnLimit: 100`

Formatting must be applied only to project-owned code. The repo already excludes generated/vendor code via `.clang-format-ignore`.

**— Language standard**

The language standard is defined by CMake and must be kept consistent across tooling.

---

# Naming & Self-Documentation

**— Intention-Oriented Naming**

Names based on intent (the "what" and "why") rather than implementation (the "how").
- Good: `BeginTransaction()`, `EnableDirectAccess()`, `WaitUntilReady()`
- Less good: `Select()`, `SetMemoryMappedMode()`, `CheckStatus()`

**— Explicit over Concise**

Clarity takes precedence over brevity. A long, precise name is preferred over a short, ambiguous one.
- Good: `remaining_bytes_to_write`, `current_buffer_index`, `sector_start_address`
- Less good: `rem`, `idx`, `addr`

**— Zero-Comment Policy (Self-Documenting Code)**
The code should be explicit enough to eliminate the need for comments.
- If logic seems complex, extract it into a well-named function or rename the variables
- Function names must use **action verbs** (e.g., `Start`, `Stop`, `Configure`, `Validate`)  describing the business or technical effect.
- Exception: Use comments only to explain "Why" a specific hardware constraint exists (e.g., specific delay required by datasheet).

**— Use Domain Vocabulary**

Use precise domain terms (hardware or business-specific) as defined in the technical documentation or wiring diagrams.
- Example: `page_size`, `sector_erase`, `quad_mode`, `bus_busy`

**— Avoid Abbreviations**

Unless the abbreviation is a universal industry standard (e.g., `SPI`, `DMA`, `ISR`), it should be avoided.
- Good: `configuration`, `transmit`, `receive`, `callback`
- Less good: `cfg`, `tx`, `rx`, `cb`


**— Unit Suffixes**

Always append units to variables representing time, frequency, or size if they are not implicit.
- Good: `timeout_ms`, `frequency_hz`, `buffer_size_bytes`
- Less good: `timeout`, `freq`, `size`

---

## 2. Project Organization

### 2.1 Target Directory Structure

```
project-root/
│
├── app/                          # Application logic (Tasks, Orchestration)
│   ├── include/
│   │   └── app/
│   │       ├── application.hpp
│   │       ├── events.hpp
│   │       ├── config.hpp
│   │       ├── messages.hpp
│   │       └── tasks/
│   │           ├── can_task.hpp
│   │           ├── midi_task.hpp
│   │           ├── display_task.hpp
│   │           └── logic_task.hpp
│   └── src/
│       ├── application.cpp
│       ├── events.cpp
│       ├── messages.cpp
│       └── tasks/
│           ├── can_task.cpp
│           ├── midi_task.cpp
│           ├── display_task.cpp
│           └── logic_task.cpp
│
├── domain/                       # Pure Business Logic (Hardware/OS Independent)
│   ├── include/
│   │   └── domain/
│   └── src/
│
├── bsp/                          # Hardware abstraction (C++)
│   ├── include/
│   │   └── bsp/
│   │       ├── can.hpp
│   │       ├── midi.hpp
│   │       └── display.hpp
│   └── src/
│       ├── can.cpp
│       ├── midi.cpp
│       └── display.cpp
│
├── Core/                         # Generated by CubeMX
│   ├── Inc/
│   └── Src/
│
├── Drivers/                      # Generated (HAL, CMSIS)
│
├── Middlewares/                  # Generated (FreeRTOS)
│
├── hardware/                     # Hardware documentation & resources
│   ├── svd/
│       └── STM32H7xxx.svd        # SVD file for debugging
│
├── os/                           # FreeRTOS abstraction (C++)
│   ├── include/
│   │   └── os/
│   │       ├── task.hpp
│   │       ├── queue.hpp
│   │       ├── mutex.hpp
│   │       └── clock.hpp
│   └── src/
│       ├── task.cpp
│       ├── queue.cpp
│       └── clock.cpp
│
├── Third_Party/                  # Vendored third-party code (unmodified)
│   └── VendorName/
│       └── LibraryName/
│
├── tests/                        # Host-only tests (separated from firmware build)
│   ├── app/                      # Mirror of App/ (only if host-testable)
│   └── domain/                   # Mirror of Domain/
│
├── USB_DEVICE/                   # Generated (USB Stack & Config)
│   ├── App/
│   └── Target/
│
├── CMakeLists.txt
├── master-devboard.ioc
└── README.md
```

### 2.2 Organization Rules

**— The `Drivers/` directory is strictly read-only**

It is never modified, extended, or patched.

**— The `USB_DEVICE/` directory is generated by CubeMX**

It contains the USB stack and its application-level configuration. Modifications are only allowed within `USER CODE` zones.

**— The `Hardware/` directory contains non-build resources**

SVD files, datasheets, schematics, pinout documentation. These files are for reference and debugging only, not included in the build process.

**— The `Third_Party/` directory contains vendored external code**

It is kept isolated from application code, and updates are handled by replacing the vendored subtree.

**— The project directory structure is documented**

Any deviation must be justified.

---

## 3. Language & Interoperability

**— The HAL remains in C**

HAL and CMSIS are never rewritten in C++.

**— The application is written in C++**

All business logic is implemented in C++.

**— C / C++ boundaries are explicit**

Any C function called from C++ is protected by `extern "C"`.

**— Standards are explicitly fixed**

The C++ standard is defined and locked in CMake.

---

## 4. Software Architecture

### 4.1 Clean Code Principles

**— Follow SOLID principles**

Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

**— Each class has a single responsibility**

One class = one clearly defined role.

**— Prefer composition over inheritance**

Build behavior through object composition rather than deep inheritance hierarchies.

**— Dependencies flow inward**

High-level modules (business logic) never depend on low-level modules (hardware). Both depend on abstractions.

**— Respect Interface Segregation (ISP)**

Components must depend on the smallest possible interface. Never inject a "Global Board" or "Global Hardware" object if a component only needs a single peripheral.

**— Respect Liskov Substitution (LSP)**

Derived classes must respect the contract of the interface. For example, if an interface is defined as non-blocking, no implementation (BSP) is allowed to introduce blocking calls or delays.

### 4.2 Dependency Inversion Principle (DIP)

**— High-level modules depend on abstractions, not concrete implementations**

Application code depends on interfaces (abstract classes), not on BSP concrete classes.

**— Define interfaces in the module that uses them**

Interfaces are owned by the client, not the implementation. BSP implements interfaces defined in App or Domain.

**— Use dependency injection via constructor**

Pass dependencies as references (`&`) to guarantee they are not null and to make dependencies explicit.

**— No dynamic allocation after initialization**

Avoid `new`/`delete` inside classes. Use static allocation or placement new during boot.

**— The Composition Root pattern is centralized**

All object instantiation and wiring happens in one place: `Application.cpp`. This is the only place allowed to know concrete BSP classes.

#### Example: Interface Definition

```cpp
// bsp/include/bsp/gpio_requirements.hpp
class GpioRequirements {
public:
 virtual ~GpioRequirements() = default;
    virtual void set() = 0;
    virtual void reset() = 0;
    virtual void toggle() = 0;
    virtual bool read() const = 0;
};
```

#### Example: Task Depending on Interface

```cpp
// app/include/app/tasks/led_task.hpp
#include "bsp/gpio_requirements.hpp" // Depends on interface, not implementation

class LedTask : public Task {
public:
    explicit LedTask(GpioRequirements& ledHardware) : _led(ledHardware) {}

    void run() override {
        _led.toggle();
    }

private:
    GpioRequirements& _led; // Reference to dependency
};
```

#### Example: Composition Root

```cpp
// app/src/application.cpp
#include "app/application.hpp"
#include "bsp/Stm32Gpio.hpp" // Concrete class known only here

void Application::boot() {
    // 1. Static instantiation (avoid heap fragmentation)
    static Stm32Gpio statusLed(GPIOA, GPIO_PIN_5);

    // 2. Dependency injection (wiring)
    static LedTask ledTask(statusLed);

    // 3. Start
    ledTask.start();
}
```

### 4.3 Application Layer (App/)

**— The application never depends on the HAL**

The application domain does not directly depend on the HAL.

**— App/ manages orchestration and real-time**

It contains FreeRTOS tasks and synchronization logic.

**— App/ depends only on BSP/OS interfaces**

Never includes concrete BSP implementations (except in Application.cpp).

### 4.4 Domain Layer (Domain/)

**— Pure logic without dependencies**

Contains algorithms and business rules independent of FreeRTOS, HAL, or BSP.

**— Highly testable**

Must be compilable and testable on a host machine (Unit Tests).

**— Domain layer never includes OS or BSP headers**

No `#include` of FreeRTOS, HAL, or BSP files.

**— Domain layer uses only standard C++ and portable libraries**

Depends only on standard library or explicitly approved portable dependencies.

**— Data structures in Domain are plain C++ types**

No hardware types (e.g., `uint32_t*` pointing to registers), no OS primitives.

**— Domain functions are deterministic and side-effect free when possible**

Pure functions facilitate testing and reasoning about behavior.

### 4.5 BSP Layer (Board Support Package)

**— The BSP is the only layer dependent on the HAL**

The application never depends on the HAL.

**— The BSP is designed to be thread-safe**

Concurrent accesses are explicitly protected.

**— The BSP contains no business logic**

Only hardware capabilities.

**— No blocking FreeRTOS calls in the BSP**

The BSP is non-blocking and thread-safe.

**— Each peripheral is encapsulated in a dedicated abstraction**

GPIO, UART, SPI, etc. are accessed via C++ classes.

### 4.6 OS Layer (FreeRTOS Abstraction)

**— FreeRTOS is never used directly in the application**

The application depends only on the OS/ layer.

**— FreeRTOS APIs are encapsulated in C++ wrappers**

Tasks, queues, mutexes, timers abstracted.

### 4.7 Configuration Management

**— Configuration is centralized in Config.hpp**

Avoid scattered `#define` across multiple files.

**— Hardware-specific configuration is separated from logic**

Board variants are handled through build-time configuration.

**— Magic numbers are replaced by named constants**

All numeric values have meaningful names and documentation.

---

## 5. FreeRTOS

### 5.1 Entry Point & Scheduler

**— `main` is an initialization point only**

Hardware initialization, OS, then scheduler launch.

**— `main` contains no application loop**

All logic executes in FreeRTOS tasks.

**— The FreeRTOS scheduler is launched only once**

No code after `vTaskStartScheduler()`.

### 5.2 Task Organization

**— Each functional domain is isolated in a task**

Communication, I/O, display, business logic separated.

**— Tasks never communicate via global variables**

Use of queues, notifications, or event groups.

**— Priorities are justified and documented**

Any non-default priority must be explained.

**— Every task, queue, and priority is documented**

Objective, responsibility, constraints.

**— Constructors do not create tasks**

Task creation is centralized and explicit.

### 5.3 Task Organization in Directory Structure

**— A task is an application component, not an isolated function**

Each task has its own files (header + source) and lives in the application space.

**— Task code is never placed in `main`, `Core/`, or `OS/`**

Tasks belong to the application (`App/`) or, more rarely, to a dedicated service.

**— One task = one directory or one clearly identified file pair**

The task name must be explicit and stable.

### 5.4 Interrupts

**— ISRs are minimal**

ISRs notify or post messages only.

### 5.5 Synchronization & Critical Sections

**— Shared resources are explicitly protected**

Every shared resource must have a defined protection mechanism (mutex, critical section).

**— Critical sections are kept as short as possible**

Minimize interrupt disable time to maintain system responsiveness.

**— Deadlock prevention is considered in design**

Document lock ordering and avoid circular dependencies.

**— Resource acquisition order is documented**

Prevent priority inversion and deadlocks.

### 5.6 CubeMX Configuration

**— FreeRTOS configuration is done only via CubeMX**

No manual modification of generated files.

**— FreeRTOS hooks use only USER CODE**

All extensions go through authorized callbacks.

---

## 6. Embedded C++ Constraints

### 6.1 Disabled Features

**— Exceptions are disabled**

No code should depend on exceptions.

**— RTTI is disabled**

No use of `dynamic_cast` or `typeid`.

### 6.2 Memory Management

**— Dynamic allocation is strictly controlled**

`new` / `delete` are avoided or strictly framed. Allocation at initialization only.

**— Complex static initializations are forbidden**

No dependency on global initialization order. No dependency on static initialization order.

---

## 7. Build & Tools

### 7.1 CMake

**— CMake is the source of truth for the build**

No critical setting depends on the IDE.

**— The project explicitly compiles in C and C++**

C, C++, and ASM languages are declared.

### 7.2 CubeMX

**— CubeMX regeneration is a safe operation**

It can be done at any time without code loss.

**— All extensions go through external files**

Never through direct modification of generated code.

---

## 8. Quality & Maintainability

**— Code must be testable off-target**

Business logic does not depend on hardware.

**— Hardware coupling is minimal and localized**

The BSP is the only layer dependent on the MCU.

**— The project must be able to evolve without CubeMX**

The application core is independent of the generation tool.

**— The HAL is never mocked directly**

C++ abstractions are mockable, not the HAL.

**— Any rule violation is explicitly documented**

No implicit exceptions.

---

## 9. Error Handling & Diagnostics

**— Error handling strategy is defined and consistent**

Define how errors are propagated: return codes, error callbacks, or assertions.

**— Critical errors are logged before system halt**

Use a diagnostic mechanism (UART, SWO, LED codes) for debugging.

**— Assert mechanisms are used in development builds**

Assertions help catch violations early but may be disabled in production.

**— Hardware fault handlers are implemented**

HardFault, MemManage, BusFault handlers provide diagnostics.

---

## 10. Testing & Validation

**— Unit tests are written for business logic**

Application layer must be testable without hardware.

**— Integration tests validate BSP behavior**

Test hardware abstractions with real or simulated peripherals.

**— Mock interfaces exist for hardware dependencies**

BSP interfaces can be mocked for off-target testing.

**— Continuous integration builds both target and host tests**

Automated testing prevents regressions.

**— TDD-Centric for domain**

Any new class or logic added to `domain/` MUST be accompanied by a corresponding unit test in `tests/domain/`.
- The agent must not consider a task "Done" if the test file is missing.
- Tests must be written before or during implementation.

**— Logic-only domain Tests**

Domain tests must never depend on HAL, FreeRTOS, or BSP. They must use Mocks (via inheritance or minimal stubs) for any `Requirements` interfaces.


### 10.1 Test Organization

**— Tests live in `tests/` and are never mixed into firmware sources**

Unit tests are built as host executables and must not be compiled or linked into the embedded firmware target.

**— `tests/` mirrors production code structure**

Test files should follow the same module and relative path as the code under test.

**— Test naming is explicit and consistent**

- `<Name>.test.cpp`

**— Domain tests stay portable**

Tests under `tests/domain/` must not include or depend on HAL, FreeRTOS, or BSP headers.

### 10.2 Test Structure (BDD & AAA Pattern)

**— Philosophy**: Use a nested BDD structure to document behavior, and the AAA (Arrange, Act, Assert) pattern for the implementation of each test case.
**— Mechanism**: Use nested Catch2 `SECTION` blocks. Each level of nesting should refine the context.
**— Hierarchy**:
  1. `TEST_CASE`: The class or component name (e.g., "The MyClass class")
  2. `SECTION` (Level 1): The Method or Feature being tested (e.g., "The method PressKey()").
  3. `SECTION` (Level 2): The Context or State (e.g., "When called with valid arguments").
  4. `SECTION` (Level 3): The Expected Outcome (e.g., "Should send the expected MIDI message").

**— Implementation (AAA)**:
Inside the final leaf `SECTION`, explicitly separate logic:
- **Arrange**: Setup the specific state, mocks expectations, and variables.
- **Act**: Call the method under test.
- **Assert**: Verify the outcomes (requirements, mock verifications).
Do not comment these sections.

**Example**:
```cpp
TEST_CASE("The MidiPiano class") {

  SECTION("The PressKey() method") {

    SECTION("When called with channel set to 5") {

      SECTION("Should correctly apply bitwise OR to status byte (0x95)") {
      }

      SECTION("Should pass note and velocity unchanged") {
      }
    }
  }
}

### 10.3 Test Execution

**— Host Environment**
Unit tests must run on the host machine. The agent should use the CMake preset `Host-Debug` for this purpose.

**— Reference Commands**
To configure, build, and execute all unit tests, the agent should prioritize the following commands:
1. Configure: `cmake --preset Host-Debug`
2. Build: `cmake --build --preset Host-Debug --target unit_tests`
3. Execute: `ctest --test-dir build/Host-Debug --output-on-failure`

**— Running a Specific Test**
To save time, the agent can filter and run only the tests matching a specific name using the `-R` option of `ctest`, for example:
`ctest --test-dir build/Host-Debug -R "The MidiPiano class" --output-on-failure`
